¬°Hola nuevamente Juli√°n! 
¬°Cada vez estamos m√°s cerca! Tranqui, veamos que est√° pasando üòâ.
Antes de ver el enunciado, veamos un ejemplo con galletitas üòÅ.

 Imaginemos que tenemos una bolsa con galletitas rellenas, 
 podr√≠amos decir que la bolsa representa una lista y que las galletitas los elementos.
Queremos que una funci√≥n tome las galletitas, 
las separe en el relleno y en las tapas, 
para luego poner en una bolsa aparte las tapas.
 Estar√≠amos mapeando nuestras galletitas.
  Ten√≠amos una bolsa (lista) de galletitas, 
  le quitamos el relleno y metimos las tapas 
  (nuevos elementos) en una nueva bola (nueva lista). 
  ¬øSuena similar? ¬°Es lo que hicimos en meses! 
  Tomamos los balances (galletitas) de la lista de balances (bolsa), 
  nos quedamos solamente con el mes del balance 
  (las tapas de las galletitas) y lo pusimos en una nueva lista (nueva bolsa).
   Hasta ah√≠ vamos perfecto.
Ahora queremos agarrar otro paquete de galletitas, 
y queremos que una funci√≥n las tome y agarre solamente las que tienen relleno de crema,
 si tiene relleno de cualquier otra cosa que no sea crema no me interesa. 
 Estamos filtrando las galletitas, 
 aquellas que s√≠ sean de crema las vamos a meter enteras en una nueva bolsa. 
 ¬øSuena similar? ¬°Claro! Es parecido a lo que hacemos en afortunados, 
 queremos tomar el balance (galletita) de la lista de balances (bolsa),
  fijarnos si tiene una ganancia mayor a 1000 (fijarnos si es de crema)
   y meterla en una nueva lista (nueva bolsa). 
   ¬°Pero ojo! Fijate que, volviendo a la galletita, 
   no la dividimos en relleno y tapas (como hicimos en el primer ejemplo), 
   si no que metimos la galletita entera a la nueva bolsa.
    Si vemos el c√≥digo que tenemos ahora:

function afortunados(balancesDeUnPeriodo) {
let fortuna  = []; //esta es nuestra nueva bolsa
for (let registro of balancesDeUnPeriodo) {
     if ((registro.ganancia)>1000) {
        agregar(fortuna, registro.mes); //ac√° estamos "metiendo las tapitas de la galletita"
        agregar(fortuna, registro.ganancia); //aca estamos "metiendo el relleno de la galletita"
      } 
    } 
return fortuna;
} 
Estamos tomando la galletita, separando en relleno y tapas y meti√©ndolo por separado a la bolsa,
 que nos termina resultando en una lista de relleno y tapas en lugar de una lista de galletitas.
  Justamente lo que necesitamos es tener la bolsa de galletitas.
   ¬øY qu√© hacemos? Bueno, podr√≠amos en lugar de separar el balance, 
   meterlo entero. Ten√© en cuenta que nuestra galletita es el registro.
    Te dejo un ejemplo con las galletitas para ver c√≥mo podr√≠a ser:


let galletasDeCrema = []
for(let galletita of bolsaDeGalletitas){
  if(galletita.relleno === "crema"){
    agregar(galletasDeCrema, galletita)  
  }
}


Fijate que en lugar de hacer:

agregar(galletasDeCreama, galletita.relleno)
agregar(galletasDeCreama, galletita.tapas)
¬°Directamente agrega la galletita entera!
¬øTe anim√°s a intentar esto en afortunados?

Sigamos ahora con mesesAfortunados. 
Retomando el ejemplo de las galletitas, 
podr√≠amos tener una funci√≥n que agarre una bolsa, 
tome las galletitas y separe primero solo aquellas que tienen la crema,
 para luego separar estas galletitas en tapas y quedarnos con ellas.
  Pero analicemos primero qu√© sucede en las funciones que hicimos antes.

Una funci√≥n nos filtraba las galletitas para quedarnos solamente con las galletitas de crema.
 Nos retornaba una bolsa nueva de galletitas.
La otra funci√≥n tomaba una bolsa de galletitas,
 y las separaba en tapas y relleno, 
 qued√°ndonos en una nueva bolsa solamente las tapas.
 
¬øNo podemos aplicarle la segunda funci√≥n al resultado de la primera?
 ¬°No necesitamos variables auxiliares! Fijate que si hacemos algo como:

tapas(galletitasDeCrema(bolsaDeGalletitas))
La computadora primero resolver√≠a galletitasDeCrema(bolsaDeGalletitas), 
que nos da una bolsa de galletitas de crema, justamente lo que recibe tapas,
 entonces puede resolver tapas(resultado de galletitasDeCrema).
Algo que tenemos que tener en cuenta es que para esta nueva funci√≥n no creamos ninguna bolsa nueva,
 si no que usamos las que nos dan las funciones tapas y galletitasDeCrema.
Ahora volviendo al c√≥digo nuestro de balances:

function mesesAfortunados(balancesDeUnPeriodo) {

    let mesFortuna     = []; //ac√° estamos creando una nueva "bolsa" ¬øla necesitamos?
    let mesListaNueva  = meses(balancesDeUnPeriodo); //ac√° tenemos una lista de toooodos los meses
    let fortunaNueva   = afortunados(balancesDeUnPeriodo); //ac√° tenemos a los balances enteros

    agregar(mesFortuna, mesListaNueva); //ac√° agregamos  toooodos los meses (tooodas las tapas)
    agregar(mesFortuna, fortunaNueva); //ac√° agregamos los balances (galletitas de crema)


return mesFortuna; 
}
Fijate que terminamos con una lista de una mezcolanza de toooodos los meses + los balances afortunados.
 Cuando en realidad solamente queremos los meses pero √∫nicamente de los afortunados.
  ¬øNo ser√° parecido a lo que vimos de las tapas de las galletitas de crema?
   ¬øTe anim√°s a probarlo con los balances? 
   Ten√© en cuenta que si no creamos una lista nueva, entonces no vamos a usar agregar.

Disculpas otra vez por lo extenso, espero que la comparaci√≥n sea de ayuda üòä.

¬°Saludos!

Cup default
Juli√°n Marcelo Z. hace 7 d√≠as
Muchas gracias nuevamente, Diana!
No es problema la extensi√≥n de la explicaci√≥n; sos muy clara transmitiendo todos los conceptos.
Entend√≠ todo lo que explicaste de la comparativa con "galletitas".

Este ejercicio me est√° haciendo doler la cabeza.
 Este Mumuki no te deja codificar libremente.
  Es muy duro, porque lo pruebo en otro lenguaje y la l√≥gica funciona perfectamente, sin errores.

Lo pruebo y te cuento.
Un gran saludo!

Cup default
Juli√°n Marcelo Z. hace 7 d√≠as
Primer problema solucionado. No puedo creer que fue por ese error. Un par√©ntesis en el retorno.
Segundo problema solucionado. Tampoco  puedo creer ese error: Al devolver lista + lista el resultado ten√≠a dos corchetes.
 Retorn√© una sola lista y funcion√≥.

Gracias totales Diana!
M√°s saludos!